/**
@file	bpatch.cpp
@brief	Program to patch tiled image files
@author Bernard Heymann
@date	Created: 20040712
@date	Modified: 20240406
**/

#include "rwmg.h"
#include "rwimg.h"
#include "img_combine.h"
#include "file_util.h"
#include "utilities.h"
#include "options.h"
#include "timer.h"
#include <fstream>

// Declaration of global variables
extern int 	verbose;		// Level of output to the screen

// Usage assistance
const char* use[] = {
" ",
"Usage: bpatch [options] input.images/input.star",
"-----------------------------------------------",
"Patches a list of tiles together with overlap.",
"Requires a text file generated by btile that specifies the size and order of the tiles.",
"Any number of input images may be given and may include the wild card \"*\".",
"All images must have the same data type.",
" ",
"Parameters:",
"-verbose 3               Verbosity of output.",
"-datatype u              Force writing of a new data type.",
"-sampling 1.5,1.5,1.5    Sampling (A/pixel; a single value can be given).",
"-origin 0.8,-10,15.7     Set the origin of the output image (default 0,0,0).",
"-size 1024,1024,120      Output image size (default from tile file).",
"-mode 1                  Overlap handling: 0=average(default), 1=weigh, 2=central.",
"-rescale 127,27.5        Rescale all input data to average and standard deviation.",
"-truncate -5,5.5         Truncate data to minimum and maximum after rescaling.",
" ",
"Input:",
"-tiles text.tiles        Text file with overall size and tile origins.",
" ",
"Output:",
"-output output.img       Output image (default patch.pif).",
"-parameters file.star    Output micrograph parameter file.",
" ",
NULL
};

int 		main(int argc, char **argv)
{
	// Initialize variables
	DataType 		nudatatype(Unknown_Type);	// Conversion to new type
	Vector3<double> sampling;					// Units for the three axes (A/pixel)
	Vector3<double> origin;						// New image origin
	int				set_origin(0);				// Flag to set origin
	Vector3<long>	size;						// Output image size
	int				flag(0);					// Overlap flag
	double			nuavg(0), nustd(0);			// Rescaling to average and stdev
	double			cutmin(0), cutmax(0); 		// Truncation
	Bstring			patchfile("patch.pif");
	Bstring			tile_file;					// Text file with overall size and tile origins
	Bstring			outparam;					// Output micrograph parameter file
	
	int				optind;
	Boption*		option = get_option_list(use, argc, argv, optind);
	Boption*		curropt;
	for ( curropt = option; curropt; curropt = curropt->next ) {
		if ( curropt->tag == "datatype" )
			nudatatype = curropt->datatype();
		if ( curropt->tag == "sampling" )
			sampling = curropt->scale();
		if ( curropt->tag == "origin" ) {
			if ( curropt->value[0] == 'c' ) {
				set_origin = 2;
			} else {
				origin = curropt->origin();
				set_origin = 1;
			}
		}
		if ( curropt->tag == "size" )
			size = curropt->size();
		if ( curropt->tag == "mode" )
			flag = curropt->value.integer();
		if ( curropt->tag == "rescale" )
        	if ( curropt->values(nuavg, nustd) < 2 )
				cerr << "-rescale: Both average and standard deviation must be specified!" << endl;
		if ( curropt->tag == "truncate" )
			if ( curropt->values(cutmin, cutmax) < 2 )
				cerr << "-truncate: Both min and max must be specified!" << endl;
		if ( curropt->tag == "output" )
			patchfile = curropt->filename();
		if ( curropt->tag == "tiles" )
			tile_file = curropt->filename();
		if ( curropt->tag == "parameters" )
			outparam = curropt->filename();
    }
	option_kill(option);

	if ( verbose && argc < 3 ) bexit(-1);
	
	double			ti = timer_start();
/*
	if ( !tile_file.length() ) {
		cerr << "Error: A text file specifying the size and tile origins must be given!" << endl;
		bexit(-1);
	}
*/
	if ( argc - optind < 1 ) {
		cerr << "Error: No tiles found!" << endl;
		bexit(-1);
	}

	Bstring*			file_list = NULL;
	while ( optind < argc ) string_add(&file_list, argv[optind++]);
	Bstring				paramfile = *file_list;
	Bproject*			project = NULL;	
	Breconstruction*	rec;

	if ( file_type(paramfile) == Micrograph ) {
		project = read_project(file_list);
		string_kill(file_list);
		file_list = NULL;
		for ( rec = project->rec; rec; rec = rec->next )
			string_add(&file_list, rec->frec);
		project_kill(project);
	}

	Bimage*		ppatch = NULL;
	
	if ( tile_file.length() )
		ppatch = img_patch(file_list, tile_file, nudatatype,
							cutmin, cutmax, nuavg, nustd);
	else {
		Bimage*			p = read_img(*file_list, 1, -1);
		if ( size.volume() < 1 )
			for ( long nn=0; nn<p->images(); ++nn )
				size = size.max(p->size()+p->image[nn].origin());
		ppatch = p->copy_header(1);
		ppatch->size(size);
		ppatch->data_alloc_and_clear();
		ppatch->assemble_tiles(p, flag);
		delete p;
	}
	
	if ( sampling.volume() > 0 ) ppatch->sampling(sampling);

	if ( set_origin ) {
		if ( set_origin == 2 ) ppatch->origin(ppatch->size()/2);
		else ppatch->origin(origin);
	}

	write_img(patchfile, ppatch, 0);
	
	Bstring			id("1");
	if ( outparam.length() ) {
		project = read_project(paramfile);
		if ( !project->rec ) reconstruction_add(&project->rec, id);
		project->rec->frec = patchfile;
		write_project(outparam, project, 0, 0);
		project_kill(project);
	}

	string_kill(file_list);
	delete ppatch;
	patchfile = 0;
	id = 0;
	
	
		timer_report(ti);
	
	bexit(0);
}

